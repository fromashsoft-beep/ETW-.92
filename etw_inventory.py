import json
import os
import re
import time

# Foundation
import etw_config as config
import etw_io as io

# Sub-Systems
import etw_bridge as bridge
import etw_loot as loot

# ----------------------------------------------------------------------
# CONSTANTS & FILES
# ----------------------------------------------------------------------
RAW_INV_FILENAME = config.INVENTORY_LOG_FILENAME
RAW_STATS_FILENAME = config.SCAN_LOG_FILENAME
CHAR_DATA_FILENAME = "character_data.json"

# ----------------------------------------------------------------------
# 1. PARSING LOGIC
# ----------------------------------------------------------------------

def get_valid_loot_codes():
    """
    Returns a dictionary of valid item suffixes (last 6 chars) mapped to their data.
    These are the items defined in the loot_*.json files.
    """
    pool = loot.get_loot_pool_cached()["all"]
    valid_map = {}
    
    for item in pool:
        code = item.get("code", "")
        if len(code) >= 6:
            # We strictly use the last 6 characters to handle load order variances (e.g. 04xxxxxx)
            suffix = code[-6:].upper()
            valid_map[suffix] = item
            
    return valid_map

def parse_raw_inventory_log(game_path):
    """
    Reads the raw output from 'player.showinventory' contained in the unified scan file.
    """
    # Uses the unified baseline filename from config
    raw_path = os.path.join(game_path, RAW_INV_FILENAME)
    lines = bridge.read_file_safely(raw_path)
    
    if not lines:
        print("Inventory Parse Warning: Log file was empty or could not be read.")
        return None # Critical: Return None to indicate failure

    valid_map = get_valid_loot_codes()
    parsed_inventory = []
    
    # Regex Update: Tuned for "1 - ItemName (ID)..." format
    # Matches: Count, Name, Full ID
    pattern = re.compile(r"^\s*(\d+)\s+-\s+(.+?)\s+\(([0-9A-Fa-f]{8})\).*")
    
    for line in lines:
        line = line.strip()
        # Skip garbage lines or headers
        if not line: continue
        if "has" in line and "items" in line and line.endswith(":"): continue 
        
        # Skip stat dump lines (GetBaseActorValue, SetConsoleOutputFilename, etc.)
        if "GetBaseActorValue" in line or "SetConsoleOutputFilename" in line or ">>" in line:
            continue

        match = pattern.match(line)
        if match:
            qty = int(match.group(1))
            full_id = match.group(3).upper()
            suffix = full_id[-6:]
            
            if suffix in valid_map:
                item_def = valid_map[suffix]
                parsed_inventory.append({
                    "code": full_id, 
                    "suffix": suffix,
                    "name": item_def["name"],
                    "category": item_def.get("category", "misc"),
                    "qty": qty
                })
            elif suffix == "00000F": # Manual check for caps
                 parsed_inventory.append({
                    "code": full_id,
                    "suffix": suffix,
                    "name": "Caps",
                    "category": "currency",
                    "qty": qty
                 })
            else:
                # UNKNOWN ITEMS (Quest items, Pipboy, Modded gear)
                # These are NOT in the loot DB, so we mark them 'unknown'
                parsed_inventory.append({
                    "code": full_id,
                    "suffix": suffix,
                    "name": match.group(2).strip(),
                    "category": "unknown",
                    "qty": qty
                })
                
    return parsed_inventory

def parse_raw_stats_log(game_path):
    """
    Parses the stats log generated by the bridge.
    Now reads from the unified baseline file.
    """
    log_path = os.path.join(game_path, RAW_STATS_FILENAME)
    lines = bridge.read_file_safely(log_path)
    
    if not lines: 
        print("Stats Parse Warning: Log file was empty or could not be read.")
        return None
    
    result = {"level": 1, "stats": {}}
    
    try:
        for line in lines:
            line = line.strip()
            if "GetLevel >>" in line:
                m = re.search(r">> ([\d\.]+)", line)
                if m: result["level"] = float(m.group(1))
            
            if "GetBaseActorValue" in line and ">>" in line:
                parts = line.split(">>")
                if len(parts) == 2:
                    val = float(parts[1].strip())
                    left = parts[0].replace("GetBaseActorValue:", "").strip().lower()
                    if left in bridge.STATS_COVERED:
                        result["stats"][left] = val
        return result
    except Exception as e:
        print(f"Inventory Module Stat Parse Error: {e}")
        return None

# ----------------------------------------------------------------------
# 2. STATE MANAGEMENT (Source of Truth)
# ----------------------------------------------------------------------

def get_character_data(game_path=None):
    char_path = os.path.join(os.getcwd(), CHAR_DATA_FILENAME)
    
    default_data = {
        "last_updated": 0,
        "caps": 0,
        "stats": {},
        "inventory": []
    }
    return io.load_json(char_path, default_data)

def save_character_data(game_path, data):
    char_path = os.path.join(os.getcwd(), CHAR_DATA_FILENAME)
    data["last_updated"] = time.time()
    return io.save_json(char_path, data)

# ----------------------------------------------------------------------
# 3. OPERATION: FULL SYNC
# ----------------------------------------------------------------------

def perform_full_inventory_sync(save_data):
    """
    Main entry point for syncing from Game to App.
    Reads from the unified 'etw_baseline' file.
    """
    game_path = save_data.get("game_install_path", "")
    if not game_path: return False
    
    # 1. Parse Inventory (Reads etw_baseline)
    inv_list = parse_raw_inventory_log(game_path)
    if inv_list is None:
        print("Sync Aborted: Inventory log missing or locked.")
        return False # Fail safe - DO NOT SAVE
        
    caps_count = 0
    final_inv_list = []
    
    for item in inv_list:
        if item.get("suffix") == "00000F" or item.get("code", "").endswith("00000F"):
            caps_count = item["qty"]
        else:
            final_inv_list.append(item)
            
    # 2. Parse Stats (Reads etw_baseline)
    stat_data = parse_raw_stats_log(game_path)
    if stat_data and stat_data.get("stats"):
        baseline = stat_data.get("stats", {})
    else:
        # If stat scan fails, try to preserve existing baseline from save_data
        print("Sync Warning: Stat scan failed, preserving existing baseline.")
        baseline = save_data.get("baseline", {})
    
    # 3. Save to Source of Truth (Only if Inventory was valid)
    char_data = {
        "caps": caps_count,
        "stats": baseline,
        "inventory": final_inv_list
    }
    
    save_character_data(game_path, char_data)
    # print("Character Data Synced Successfully.")
    return True

# ----------------------------------------------------------------------
# 4. OPERATION: LOCAL UPDATE
# ----------------------------------------------------------------------

def update_local_inventory(save_data, added_items=None, removed_items=None, caps_change=0):
    game_path = save_data.get("game_install_path", "")
    if not game_path: return

    char_data = get_character_data(game_path)
    current_inv = char_data.get("inventory", [])
    current_caps = char_data.get("caps", 0)
    
    def _find_index(code):
        for i, item in enumerate(current_inv):
            if item["code"] == code: return i
        return -1

    if added_items:
        pool = loot.get_loot_pool_cached()["all"]
        for new_item in added_items:
            code = new_item["code"]
            qty = new_item.get("qty", 1)
            idx = _find_index(code)
            
            if idx >= 0:
                current_inv[idx]["qty"] += qty
            else:
                ref = None
                for p in pool:
                    if p.get("code") == code:
                        ref = p; break
                if not ref:
                    suffix = code[-6:] if len(code) >= 6 else code
                    for p in pool:
                        if p.get("code", "").endswith(suffix):
                            ref = p; break
                            
                name = ref["name"] if ref else "Unknown Item"
                cat = ref.get("category", "misc") if ref else "misc"
                
                current_inv.append({
                    "code": code,
                    "qty": qty,
                    "name": name,
                    "category": cat
                })

    if removed_items:
        for rem_item in removed_items:
            code = rem_item["code"]
            qty = rem_item.get("qty", 1)
            idx = _find_index(code)
            
            if idx >= 0:
                current_inv[idx]["qty"] = max(0, current_inv[idx]["qty"] - qty)
                
        current_inv = [i for i in current_inv if i["qty"] > 0]

    new_caps = max(0, current_caps + caps_change)

    char_data["inventory"] = current_inv
    char_data["caps"] = new_caps
    
    save_character_data(game_path, char_data)

# ----------------------------------------------------------------------
# 5. DEATH LOGIC
# ----------------------------------------------------------------------

def calculate_death_losses(save_data):
    """
    Determines which items to remove upon death.
    STRICT FILTERING: Only removes items explicitly found in the Loot DB (loot_*.json).
    Everything else (Quest items, mod items, pipboy, keys) is SAFE.
    """
    game_path = save_data.get("game_install_path", "")
    insured_items = save_data.get("insured_items", [])
    
    char_data = get_character_data(game_path)
    current_inv = char_data.get("inventory", [])
    
    # 1. Load the Strict Allowlist (Loot DB)
    valid_map = get_valid_loot_codes()
    
    removal_commands = []
    removed_items_data = []
    
    for item in current_inv:
        code = item["code"]
        
        # 2. Insurance Check (Priority)
        if code in insured_items:
            continue
            
        # 3. Database Check
        # We rely strictly on the 6-character suffix to match the vanilla FormIDs in the JSONs.
        # This handles load order prefixes (e.g. 04xxxxxx vs 00xxxxxx).
        suffix = code[-6:].upper() if len(code) >= 6 else code.upper()
        
        # KEY LOGIC FIX:
        # If suffix is IN valid_map, it is a recognized Loot Item -> REMOVE.
        # If suffix is NOT in valid_map, it is a Quest/Mod/Unique item -> SAFE.
        
        if suffix in valid_map:
            # It IS in the loot tables -> REMOVE IT
            qty = item["qty"]
            if qty > 0:
                removal_commands.append(f"player.removeitem {code} {qty}")
                removed_items_data.append({"code": code, "qty": qty})
        
        # Manual check for Caps (if not in loot tables, but we want them gone)
        # However, loot_misc.json usually contains caps (0000000F).
        # If it doesn't, and we want to lose money, uncomment below.
        # But per instruction "compare to loot_*.json", we trust the JSONs.
        elif suffix == "00000F": 
             # Caps are usually in loot_misc.json, but this is a failsafe to ensure death has cost
             # if the JSON is edited.
             pass 

    return removal_commands, removed_items_data

# ----------------------------------------------------------------------
# 6. VERIFICATION & REMOVAL HELPER
# ----------------------------------------------------------------------

def verify_and_remove_items(save_data, required_items):
    """
    Checks if the player has the required items in the Source of Truth.
    If yes: Executes removal commands via Bridge and updates Source of Truth.
    If no: Returns missing items list.
    
    required_items: list of dicts [{'code': 'XXX', 'qty': 1, 'name': 'Optional'}, ...]
    """
    game_path = save_data.get("game_install_path", "")
    char_data = get_character_data(game_path)
    current_inv = char_data.get("inventory", [])
    
    missing_items = []
    items_to_remove_cmd = []
    items_to_remove_json = []
    
    # 1. Verification Pass
    for req in required_items:
        req_code = req.get("code")
        req_qty = req.get("qty", 1)
        req_name = req.get("name", "Unknown Item")
        
        # Suffix matching logic
        req_suffix = req_code[-6:] if len(req_code) >= 6 else req_code
        
        found_qty = 0
        found_code = None # Actual code in inventory (might differ from refID if modded)
        
        for inv_item in current_inv:
            inv_code = inv_item.get("code", "")
            inv_suffix = inv_code[-6:] if len(inv_code) >= 6 else inv_code
            
            if inv_code == req_code or inv_suffix == req_suffix:
                found_qty = inv_item.get("qty", 0)
                found_code = inv_code
                break
        
        if found_qty < req_qty:
            missing_items.append(f"{req_name} (Need {req_qty}, Have {found_qty})")
        else:
            # Prepare removal data
            items_to_remove_cmd.append(f"player.removeitem {found_code} {req_qty}")
            items_to_remove_json.append({"code": found_code, "qty": req_qty})

    if missing_items:
        return {"success": False, "missing": missing_items}
    
    # 2. Execution Pass (Only if verification passed for ALL items)
    if items_to_remove_cmd:
        # Send verified batch to game
        # Note: Using default blocking verification here to ensure transactional safety
        if bridge.execute_batch_with_verification(game_path, items_to_remove_cmd):
            # Update local JSON
            update_local_inventory(save_data, removed_items=items_to_remove_json)
            return {"success": True}
        else:
            return {"success": False, "msg": "Game Communication Failed"}
            
    return {"success": True} # No items to remove (empty reqs)